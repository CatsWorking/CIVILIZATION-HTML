<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Top-Down Shooter</title>
<style>
  canvas { background: #222; display: block; margin: 0 auto; }
  body { text-align: center; color: white; font-family: sans-serif; }
</style>
</head>
<body>
<h1>Top-Down Shooter</h1>
<p id="teamInfo">Loading...</p>
<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Load map
const mapImg = new Image();
mapImg.src = 'rd_donut.png';

const TILE_COLORS = {
    spawnDisassembly: '#ff7f27',
    spawnReassembly: '#fff200',
    walkable: ['#ff7f27', '#fff200', '#c3c3c3'],
    wall: '#000000'
};

const PLAYER_SIZE = 10;
const FOV_ANGLE = Math.PI / 2; // 90 degrees
const ROUND_TIME = 150; // 2:30 in seconds

let mapData = null;

// Entity constructor
class Entity {
    constructor(x, y, team, color, isBot=false) {
        this.x = x;
        this.y = y;
        this.team = team;
        this.color = color;
        this.isBot = isBot;
        this.health = 100;
        this.weaponIndex = 0;
        this.weaponCooldown = 0;
        this.target = null;
        this.lastSeenPos = null;
    }
}

// Weapons
const weapons = [
    {name:'Shotgun', fireRate:2, pellets:5, damage:10, automatic:false},
    {name:'Pistol', fireRate:10, pellets:1, damage:30, automatic:false},
    {name:'SMG', fireRate:30, pellets:1, damage:5, automatic:true}
];

// Game state
let player = null;
let bots = [];
let bullets = [];
let splashes = [];
let keys = {};
let mouse = {x:0, y:0};
let roundTimer = ROUND_TIME;
let roundActive = false;
let lastTime = 0;

// Utility
function hexToRgb(hex) {
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    return {r,g,b};
}

// Load map pixels
mapImg.onload = function(){
    const tmpCanvas = document.createElement('canvas');
    tmpCanvas.width = mapImg.width;
    tmpCanvas.height = mapImg.height;
    const tmpCtx = tmpCanvas.getContext('2d');
    tmpCtx.drawImage(mapImg,0,0);
    mapData = tmpCtx.getImageData(0,0,mapImg.width,mapImg.height);
    initGame();
};

// Initialize game
function initGame() {
    // Find spawn points
    const spawnPointsDis = [];
    const spawnPointsRea = [];
    for(let y=0;y<mapImg.height;y++){
        for(let x=0;x<mapImg.width;x++){
            const idx = (y*mapImg.width + x)*4;
            const r = mapData.data[idx];
            const g = mapData.data[idx+1];
            const b = mapData.data[idx+2];
            const hex = rgbToHex(r,g,b);
            if(hex === TILE_COLORS.spawnDisassembly) spawnPointsDis.push({x,y});
            if(hex === TILE_COLORS.spawnReassembly) spawnPointsRea.push({x,y});
        }
    }

    // Spawn player on random Reassembly tile
    const pSpawn = spawnPointsRea[Math.floor(Math.random()*spawnPointsRea.length)];
    player = new Entity(pSpawn.x,pSpawn.y,'Reassembly',TILE_COLORS.spawnReassembly,false);

    document.getElementById('teamInfo').textContent = `YOU ARE ON TEAM ${player.team}!`;

    // Spawn bots
    for(let i=0;i<6;i++){
        let bSpawn, team, color;
        if(i<3){
            team='Disassembly';
            color=TILE_COLORS.spawnDisassembly;
            bSpawn=spawnPointsDis[Math.floor(Math.random()*spawnPointsDis.length)];
        } else {
            team='Reassembly';
            color=TILE_COLORS.spawnReassembly;
            bSpawn=spawnPointsRea[Math.floor(Math.random()*spawnPointsRea.length)];
        }
        bots.push(new Entity(bSpawn.x,bSpawn.y,team,color,true));
    }

    roundActive = true;
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

// Convert RGB to hex
function rgbToHex(r,g,b){
    return "#" + ((1 << 24) + (r <<16) + (g<<8) + b).toString(16).slice(1);
}

// Movement & collision
function isWalkable(x,y){
    const ix = Math.floor(x);
    const iy = Math.floor(y);
    if(ix<0 || iy<0 || ix>=mapImg.width || iy>=mapImg.height) return false;
    const idx = (iy*mapImg.width + ix)*4;
    const r = mapData.data[idx];
    const g = mapData.data[idx+1];
    const b = mapData.data[idx+2];
    const hex = rgbToHex(r,g,b);
    return TILE_COLORS.walkable.includes(hex);
}

// Input
window.addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);
canvas.addEventListener('mousemove',e=>{
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
});
window.addEventListener('keypress',e=>{
    if(e.key.toLowerCase()==='q'){
        player.weaponIndex = (player.weaponIndex+1)%weapons.length;
    }
});

// Game Loop
function gameLoop(ts){
    const dt = (ts - lastTime)/1000;
    lastTime = ts;
    if(roundActive) roundTimer -= dt;
    update(dt);
    render();
    if(roundActive) requestAnimationFrame(gameLoop);
}

// Update entities
function update(dt){
    // Player movement
    const speed=60*dt;
    let dx=0,dy=0;
    if(keys['w']) dy-=speed;
    if(keys['s']) dy+=speed;
    if(keys['a']) dx-=speed;
    if(keys['d']) dx+=speed;
    if(isWalkable(player.x+dx,player.y)) player.x+=dx;
    if(isWalkable(player.x,player.y+dy)) player.y+=dy;

    // Player shooting
    const weapon = weapons[player.weaponIndex];
    if(keys[' ']) shoot(player);

    if(player.weaponCooldown>0) player.weaponCooldown-=dt;

    // Update bots
    bots.forEach(bot=>{
        if(bot.health<=0) return;
        botThink(bot,dt);
    });

    // Update bullets
    bullets.forEach((b,i)=>{
        b.x+=b.vx*dt;
        b.y+=b.vy*dt;
        if(!isWalkable(b.x,b.y)) bullets.splice(i,1);
        // Hit detection
        const entities=[player,...bots];
        entities.forEach(ent=>{
            if(ent.health>0 && ent.team!==b.owner.team){
                if(Math.hypot(ent.x-b.x,ent.y-b.y)<PLAYER_SIZE){
                    ent.health-=b.damage;
                    bullets.splice(i,1);
                    splashes.push({x:b.x,y:b.y,time:0});
                }
            }
        });
    });

    // Update splashes
    splashes.forEach((s,i)=>{
        s.time+=dt;
        if(s.time>2) splashes.splice(i,1);
    });

    // Check round end
    const teamsAlive = new Set();
    if(player.health>0) teamsAlive.add(player.team);
    bots.forEach(b=>{if(b.health>0) teamsAlive.add(b.team)});
    if(teamsAlive.size<=1 || roundTimer<=0){
        roundActive=false;
        alert(teamsAlive.has('Reassembly')?'Reassembly Wins!':'Disassembly Wins!');
    }
}

// Bot AI
function botThink(bot,dt){
    const speed=50*dt;
    // Find visible enemies
    const visible = [];
    const entities=[player,...bots];
    entities.forEach(ent=>{
        if(ent===bot || ent.team===bot.team || ent.health<=0) return;
        const angle=Math.atan2(ent.y-bot.y,ent.x-bot.x);
        const dist=Math.hypot(ent.x-bot.x,ent.y-bot.y);
        const dx=Math.cos(angle), dy=Math.sin(angle);
        if(dist<150) visible.push({entity:ent,angle,dist});
    });

    let target=null;
    if(visible.length>0){
        target=visible[0].entity;
        bot.lastSeenPos={x:target.x,y:target.y};
    } else if(bot.lastSeenPos) target={x:bot.lastSeenPos.x, y:bot.lastSeenPos.y};

    if(target){
        const angle=Math.atan2(target.y-bot.y,target.x-bot.x);
        const vx=Math.cos(angle)*speed;
        const vy=Math.sin(angle)*speed;
        if(isWalkable(bot.x+vx,bot.y+vy)) bot.x+=vx;
        if(isWalkable(bot.x,bot.y+vy)) bot.y+=vy;
        if(bot.weaponCooldown<=0 && target.health>0) shoot(bot);
        if(bot.lastSeenPos && Math.hypot(bot.x-bot.lastSeenPos.x,bot.y-bot.lastSeenPos.y)<5) bot.lastSeenPos=null;
    } else {
        // wander
        const dir=Math.random()*Math.PI*2;
        if(isWalkable(bot.x+Math.cos(dir)*speed,bot.y+Math.sin(dir)*speed)){
            bot.x+=Math.cos(dir)*speed;
            bot.y+=Math.sin(dir)*speed;
        }
    }
    if(bot.weaponCooldown>0) bot.weaponCooldown-=dt;
}

// Shooting
function shoot(entity){
    const weapon = weapons[entity.weaponIndex];
    if(entity.weaponCooldown>0) return;
    const angle = entity.isBot ? Math.atan2(entity.lastSeenPos.y-entity.y, entity.lastSeenPos.x-entity.x) : Math.atan2(mouse.y-entity.y, mouse.x-entity.x);
    for(let i=0;i<weapon.pellets;i++){
        const spread=(Math.random()-0.5)*0.2;
        bullets.push({x:entity.x,y:entity.y,vx:Math.cos(angle+spread)*200,vy:Math.sin(angle+spread)*200,damage:weapon.damage,owner:entity});
    }
    entity.weaponCooldown = 1/weapon.fireRate;
}

// Render
function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Draw map (simplified as background)
    ctx.drawImage(mapImg,0,0,canvas.width,canvas.height);

    // Draw entities
    [player,...bots].forEach(e=>{
        if(e.health<=0) return;
        ctx.fillStyle=e.color;
        ctx.beginPath();
        ctx.arc(e.x,e.y,PLAYER_SIZE,0,Math.PI*2);
        ctx.fill();

        // FOV cone for player
        if(!e.isBot){
            ctx.fillStyle='rgba(255,255,255,0.2)';
            ctx.beginPath();
            const angle=Math.atan2(mouse.y-e.y,mouse.x-e.x);
            ctx.moveTo(e.x,e.y);
            ctx.arc(e.x,e.y,100,angle-FOV_ANGLE/2,angle+FOV_ANGLE/2);
            ctx.closePath();
            ctx.fill();
        }
    });

    // Draw bullets
    ctx.strokeStyle='orange';
    bullets.forEach(b=>{
        ctx.beginPath();
        ctx.moveTo(b.x-b.vx*0.01,b.y-b.vy*0.01);
        ctx.lineTo(b.x,b.y);
        ctx.stroke();
    });

    // Draw splashes
    ctx.fillStyle='red';
    splashes.forEach(s=>{
        ctx.globalAlpha = 1 - s.time/2;
        ctx.beginPath();
        ctx.arc(s.x,s.y,3,0,Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
    });

    // Draw round timer
    ctx.fillStyle='white';
    ctx.fillText(`Time Left: ${Math.floor(roundTimer)}s`, 10, 20);
}
</script>
</body>
</html>
