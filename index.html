<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Top-Down Shooter</title>
<style>
  canvas { background: #222; display: block; margin: 0 auto; }
  body { text-align: center; color: white; font-family: sans-serif; }
</style>
</head>
<body>
<h1>Top-Down Shooter</h1>
<p id="teamInfo">Loading...</p>
<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Map settings
const TILE_SIZE = 10;
const MAP_WIDTH = canvas.width / TILE_SIZE;
const MAP_HEIGHT = canvas.height / TILE_SIZE;

const TILE_COLORS = {
    spawnDisassembly: '#ff7f27',
    spawnReassembly: '#fff200',
    walkable: ['#ff7f27', '#fff200', '#c3c3c3'],
    wall: '#000000'
};

// Procedural map array
let mapGrid = [];

// Generate map
function generateMap() {
    for(let y=0;y<MAP_HEIGHT;y++){
        mapGrid[y]=[];
        for(let x=0;x<MAP_WIDTH;x++){
            const rand=Math.random();
            if(rand<0.1) mapGrid[y][x]=TILE_COLORS.spawnDisassembly;
            else if(rand<0.2) mapGrid[y][x]=TILE_COLORS.spawnReassembly;
            else if(rand<0.7) mapGrid[y][x]='#c3c3c3';
            else mapGrid[y][x]=TILE_COLORS.wall;
        }
    }
}

// Player & bot settings
const PLAYER_SIZE = TILE_SIZE/2;
const FOV_ANGLE = Math.PI/2; // 90 degrees
const ROUND_TIME = 150; // seconds

// Entity constructor
class Entity {
    constructor(x, y, team, color, isBot=false) {
        this.x = x;
        this.y = y;
        this.team = team;
        this.color = color;
        this.isBot = isBot;
        this.health = 100;
        this.weaponIndex = 0;
        this.weaponCooldown = 0;
        this.lastSeenPos = null;
    }
}

// Weapons
const weapons = [
    {name:'Shotgun', fireRate:2, pellets:5, damage:10, automatic:false},
    {name:'Pistol', fireRate:10, pellets:1, damage:30, automatic:false},
    {name:'SMG', fireRate:30, pellets:1, damage:5, automatic:true}
];

// Game state
let player=null;
let bots=[];
let bullets=[];
let splashes=[];
let keys={};
let mouse={x:0,y:0};
let roundTimer=ROUND_TIME;
let roundActive=false;
let lastTime=0;

// Map walkability
function isWalkable(x,y){
    const ix=Math.floor(x/TILE_SIZE);
    const iy=Math.floor(y/TILE_SIZE);
    if(ix<0||iy<0||ix>=MAP_WIDTH||iy>=MAP_HEIGHT) return false;
    return TILE_COLORS.walkable.includes(mapGrid[iy][ix]);
}

// Input
window.addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);
canvas.addEventListener('mousemove',e=>{
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
});
window.addEventListener('keypress',e=>{
    if(e.key.toLowerCase()==='q'){
        player.weaponIndex = (player.weaponIndex+1)%weapons.length;
    }
});

// Initialize game
function initGame() {
    generateMap();

    // Find spawn points
    const spawnPointsDis=[];
    const spawnPointsRea=[];
    for(let y=0;y<MAP_HEIGHT;y++){
        for(let x=0;x<MAP_WIDTH;x++){
            if(mapGrid[y][x]===TILE_COLORS.spawnDisassembly) spawnPointsDis.push({x:x*TILE_SIZE+TILE_SIZE/2, y:y*TILE_SIZE+TILE_SIZE/2});
            if(mapGrid[y][x]===TILE_COLORS.spawnReassembly) spawnPointsRea.push({x:x*TILE_SIZE+TILE_SIZE/2, y:y*TILE_SIZE+TILE_SIZE/2});
        }
    }

    // Spawn player on random Reassembly tile
    const pSpawn = spawnPointsRea[Math.floor(Math.random()*spawnPointsRea.length)];
    player = new Entity(pSpawn.x,pSpawn.y,'Reassembly',TILE_COLORS.spawnReassembly,false);
    document.getElementById('teamInfo').textContent = `YOU ARE ON TEAM ${player.team}!`;

    // Spawn bots
    for(let i=0;i<6;i++){
        let bSpawn, team, color;
        if(i<3){
            team='Disassembly';
            color=TILE_COLORS.spawnDisassembly;
            bSpawn=spawnPointsDis[Math.floor(Math.random()*spawnPointsDis.length)];
        } else {
            team='Reassembly';
            color=TILE_COLORS.spawnReassembly;
            bSpawn=spawnPointsRea[Math.floor(Math.random()*spawnPointsRea.length)];
        }
        bots.push(new Entity(bSpawn.x,bSpawn.y,team,color,true));
    }

    roundActive = true;
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

// Shooting
function shoot(entity){
    const weapon = weapons[entity.weaponIndex];
    if(entity.weaponCooldown>0) return;
    const angle = entity.isBot && entity.lastSeenPos ? Math.atan2(entity.lastSeenPos.y-entity.y, entity.lastSeenPos.x-entity.x) : Math.atan2(mouse.y-entity.y, mouse.x-entity.x);
    for(let i=0;i<weapon.pellets;i++){
        const spread=(Math.random()-0.5)*0.2;
        bullets.push({x:entity.x,y:entity.y,vx:Math.cos(angle+spread)*200,vy:Math.sin(angle+spread)*200,damage:weapon.damage,owner:entity});
    }
    entity.weaponCooldown = 1/weapon.fireRate;
}

// --- A* Pathfinding for bots ---
function findPath(startX, startY, goalX, goalY) {
    const cols = MAP_WIDTH;
    const rows = MAP_HEIGHT;

    function nodeKey(x,y){return x+","+y;}
    function heuristic(x1,y1,x2,y2){return Math.abs(x1-x2)+Math.abs(y1-y2);}

    const openSet = [{x:startX, y:startY, g:0, h:heuristic(startX,startY,goalX,goalY), parent:null}];
    const closedSet = new Set();

    while(openSet.length>0){
        openSet.sort((a,b)=> (a.g+a.h)-(b.g+b.h));
        const current = openSet.shift();
        if(current.x === goalX && current.y === goalY){
            const path=[];
            let c=current;
            while(c.parent){path.push({x:c.x, y:c.y}); c=c.parent;}
            path.reverse();
            return path;
        }
        closedSet.add(nodeKey(current.x,current.y));
        const dirs=[[0,1],[1,0],[0,-1],[-1,0]];
        for(let d of dirs){
            const nx=current.x+d[0], ny=current.y+d[1];
            if(nx<0||ny<0||nx>=cols||ny>=rows) continue;
            if(!TILE_COLORS.walkable.includes(mapGrid[ny][nx])) continue;
            if(closedSet.has(nodeKey(nx,ny))) continue;
            const gNew = current.g + 1;
            const hNew = heuristic(nx,ny,goalX,goalY);
            openSet.push({x:nx, y:ny, g:gNew, h:hNew, parent:current});
        }
    }
    return [];
}

// --- Bot AI ---
function botThink(bot,dt){
    const speed = 50*dt;
    const tileX = Math.floor(bot.x/TILE_SIZE);
    const tileY = Math.floor(bot.y/TILE_SIZE);

    // Find visible enemies
    const visible=[];
    const entities=[player,...bots];
    entities.forEach(ent=>{
        if(ent===bot || ent.team===bot.team || ent.health<=0) return;
        const dx = ent.x - bot.x;
        const dy = ent.y - bot.y;
        const dist = Math.hypot(dx,dy);
        if(dist<150) visible.push(ent);
    });

    let target = null;
    if(visible.length>0){
        target = visible[0];
        bot.lastSeenPos = {x: target.x, y: target.y};
    } else if(bot.lastSeenPos){
        target = {x: bot.lastSeenPos.x, y: bot.lastSeenPos.y};
    }

    if(target){
        const goalX = Math.floor(target.x / TILE_SIZE);
        const goalY = Math.floor(target.y / TILE_SIZE);
        const path = findPath(tileX, tileY, goalX, goalY);
        if(path.length>0){
            const next = path[0];
            const nextX = next.x*TILE_SIZE + TILE_SIZE/2;
            const nextY = next.y*TILE_SIZE + TILE_SIZE/2;
            const angle = Math.atan2(nextY-bot.y, nextX-bot.x);
            const vx = Math.cos(angle)*speed;
            const vy = Math.sin(angle)*speed;
            if(isWalkable(bot.x+vx, bot.y)) bot.x += vx;
            if(isWalkable(bot.x, bot.y+vy)) bot.y += vy;
        }
        // Shoot if enemy in visible list
        if(bot.weaponCooldown<=0 && visible.includes(target)) shoot(bot);
        if(bot.lastSeenPos && Math.hypot(bot.x-bot.lastSeenPos.x, bot.y-bot.lastSeenPos.y)<5) bot.lastSeenPos=null;
    } else {
        const dir=Math.random()*Math.PI*2;
        const vx=Math.cos(dir)*speed;
        const vy=Math.sin(dir)*speed;
        if(isWalkable(bot.x+vx, bot.y)) bot.x+=vx;
        if(isWalkable(bot.x, bot.y+vy)) bot.y+=vy;
    }

    if(bot.weaponCooldown>0) bot.weaponCooldown-=dt;
}

// Game Loop
function gameLoop(ts){
    const dt = (ts - lastTime)/1000;
    lastTime = ts;
    if(roundActive) roundTimer -= dt;
    update(dt);
    render();
    if(roundActive) requestAnimationFrame(gameLoop);
}

// Update
function update(dt){
    const speed=60*dt;
    let dx=0,dy=0;
    if(keys['w']) dy-=speed;
    if(keys['s']) dy+=speed;
    if(keys['a']) dx-=speed;
    if(keys['d']) dx+=speed;
    if(isWalkable(player.x+dx,player.y)) player.x+=dx;
    if(isWalkable(player.x,player.y+dy)) player.y+=dy;

    const weapon = weapons[player.weaponIndex];
    if(keys[' ']) shoot(player);
    if(player.weaponCooldown>0) player.weaponCooldown-=dt;

    bots.forEach(bot=>{if(bot.health>0) botThink(bot,dt);});

    bullets.forEach((b,i)=>{
        b.x+=b.vx*dt;
        b.y+=b.vy*dt;
        if(!isWalkable(b.x,b.y)) bullets.splice(i,1);
        const entities=[player,...bots];
        entities.forEach(ent=>{
            if(ent.health>0 && ent.team!==b.owner.team){
                if(Math.hypot(ent.x-b.x,ent.y-b.y)<PLAYER_SIZE){
                    ent.health-=b.damage;
                    bullets.splice(i,1);
                    splashes.push({x:b.x,y:b.y,time:0});
                }
            }
        });
    });

    splashes.forEach((s,i)=>{
        s.time+=dt;
        if(s.time>2) splashes.splice(i,1);
    });

    const teamsAlive = new Set();
    if(player.health>0) teamsAlive.add(player.team);
    bots.forEach(b=>{if(b.health>0) teamsAlive.add(b.team)});
    if(teamsAlive.size<=1 || roundTimer<=0){
        roundActive=false;
        alert(teamsAlive.has('Reassembly')?'Reassembly Wins!':'Disassembly Wins!');
    }
}

// Render
function render(){
    // Draw map
    for(let y=0;y<MAP_HEIGHT;y++){
        for(let x=0;x<MAP_WIDTH;x++){
            ctx.fillStyle = mapGrid[y][x];
            ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
    }

    // Draw entities
    [player,...bots].forEach(e=>{
        if(e.health<=0) return;
        ctx.fillStyle=e.color;
        ctx.beginPath();
        ctx.arc(e.x,e.y,PLAYER_SIZE,0,Math.PI*2);
        ctx.fill();

        if(!e.isBot){
            ctx.fillStyle='rgba(255,255,255,0.2)';
            ctx.beginPath();
            const angle=Math.atan2(mouse.y-e.y,mouse.x-e.x);
            ctx.moveTo(e.x,e.y);
            ctx.arc(e.x,e.y,100,angle-FOV_ANGLE/2,angle+FOV_ANGLE/2);
            ctx.closePath();
            ctx.fill();
        }
    });

    // Draw bullets
    ctx.strokeStyle='orange';
    bullets.forEach(b=>{
        ctx.beginPath();
        ctx.moveTo(b.x-b.vx*0.01,b.y-b.vy*0.01);
        ctx.lineTo(b.x,b.y);
        ctx.stroke();
    });

    // Draw splashes
    ctx.fillStyle='red';
    splashes.forEach(s=>{
        ctx.globalAlpha = 1 - s.time/2;
        ctx.beginPath();
        ctx.arc(s.x,s.y,3,0,Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
    });

    // Draw round timer
    ctx.fillStyle='white';
    ctx.fillText(`Time Left: ${Math.floor(roundTimer)}s`, 10, 20);
}

// Start game
initGame();
</script>
</body>
</html>
